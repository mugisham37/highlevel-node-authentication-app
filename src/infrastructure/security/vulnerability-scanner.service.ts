/**
 * Vulnerability Scanner Integration Service
 * Integrates with security scanning tools and manages vulnerability assessments
 */

import { logger } from '../logging/winston-logger';
import { auditTrailManager, AuditHelpers } from '../monitoring/audit-trail';
import { metricsManager } from '../monitoring/prometheus-metrics';

export interface VulnerabilityReport {
  id: string;
  scanType:
    | 'dependency'
    | 'code'
    | 'infrastructure'
    | 'configuration'
    | 'runtime';
  timestamp: Date;
  status: 'running' | 'completed' | 'failed';
  summary: {
    total: number;
    critical: number;
    high: number;
    medium: number;
    low: number;
    info: number;
  };
  vulnerabilities: Vulnerability[];
  metadata: {
    scanner: string;
    version: string;
    duration: number;
    target: string;
  };
}

export interface Vulnerability {
  id: string;
  cve?: string;
  title: string;
  description: string;
  severity: 'critical' | 'high' | 'medium' | 'low' | 'info';
  score: number; // CVSS score
  category: string;
  component: string;
  version?: string;
  fixedVersion?: string;
  references: string[];
  exploitable: boolean;
  patchAvailable: boolean;
  firstDetected: Date;
  lastSeen: Date;
  status:
    | 'open'
    | 'acknowledged'
    | 'fixed'
    | 'false_positive'
    | 'accepted_risk';
  remediation?: {
    description: string;
    effort: 'low' | 'medium' | 'high';
    priority: number;
    dueDate?: Date;
  };
}

export interface ScanConfiguration {
  enabled: boolean;
  schedule: string; // cron expression
  scanTypes: string[];
  thresholds: {
    critical: number;
    high: number;
    medium: number;
    failBuild: boolean;
  };
  integrations: {
    snyk?: {
      token: string;
      orgId: string;
    };
    sonarqube?: {
      url: string;
      token: string;
      projectKey: string;
    };
    owasp?: {
      enabled: boolean;
      suppressionFile?: string;
    };
    trivy?: {
      enabled: boolean;
      dbPath?: string;
    };
  };
}

export class VulnerabilityScannerService {
  private readonly reports = new Map<string, VulnerabilityReport>();
  private readonly vulnerabilities = new Map<string, Vulnerability>();
  private readonly config: ScanConfiguration;
  private scanInterval?: NodeJS.Timeout;

  constructor(config?: Partial<ScanConfiguration>) {
    this.config = {
      enabled: true,
      schedule: '0 2 * * *', // Daily at 2 AM
      scanTypes: ['dependency', 'code', 'configuration'],
      thresholds: {
        critical: 0,
        high: 5,
        medium: 20,
        failBuild: false,
      },
      integrations: {},
      ...config,
    };

    if (this.config.enabled) {
      this.startScheduledScans();
    }
  }

  /**
   * Run dependency vulnerability scan
   */
  async scanDependencies(): Promise<VulnerabilityReport> {
    const reportId = `dep_scan_${Date.now()}`;
    const startTime = Date.now();

    logger.info('Starting dependency vulnerability scan', { reportId });

    const report: VulnerabilityReport = {
      id: reportId,
      scanType: 'dependency',
      timestamp: new Date(),
      status: 'running',
      summary: { total: 0, critical: 0, high: 0, medium: 0, low: 0, info: 0 },
      vulnerabilities: [],
      metadata: {
        scanner: 'npm-audit',
        version: '1.0.0',
        duration: 0,
        target: 'package.json',
      },
    };

    this.reports.set(reportId, report);

    try {
      // Run npm audit
      const npmAuditResults = await this.runNpmAudit();

      // Run Snyk scan if configured
      let snykResults: any[] = [];
      if (this.config.integrations.snyk?.token) {
        snykResults = await this.runSnykScan();
      }

      // Process results
      const vulnerabilities = this.processNpmAuditResults(
        npmAuditResults
      ).concat(this.processSnykResults(snykResults));

      // Update report
      report.vulnerabilities = vulnerabilities;
      report.summary = this.calculateSummary(vulnerabilities);
      report.status = 'completed';
      report.metadata.duration = Date.now() - startTime;

      // Store vulnerabilities
      vulnerabilities.forEach((vuln) => {
        this.vulnerabilities.set(vuln.id, vuln);
      });

      // Record metrics
      metricsManager.recordSecurityEvent(
        'vulnerability_scan_completed',
        report.summary.critical > 0
          ? 'critical'
          : report.summary.high > 0
            ? 'high'
            : 'low',
        'dependency-scanner',
        report.summary.total
      );

      // Audit trail
      await auditTrailManager.recordEvent({
        actor: AuditHelpers.createSystemActor('vulnerability-scanner'),
        action: 'dependency_scan_completed',
        resource: AuditHelpers.createResource('vulnerability_scan', reportId),
        outcome: AuditHelpers.createSuccessOutcome(),
        metadata: {
          scanType: 'dependency',
          vulnerabilitiesFound: report.summary.total,
          criticalVulnerabilities: report.summary.critical,
          duration: report.metadata.duration,
        },
      });

      logger.info('Dependency vulnerability scan completed', {
        reportId,
        vulnerabilities: report.summary,
        duration: report.metadata.duration,
      });

      return report;
    } catch (error) {
      report.status = 'failed';
      report.metadata.duration = Date.now() - startTime;

      logger.error('Dependency vulnerability scan failed', {
        reportId,
        error: (error as Error).message,
        duration: report.metadata.duration,
      });

      // Audit trail
      await auditTrailManager.recordEvent({
        actor: AuditHelpers.createSystemActor('vulnerability-scanner'),
        action: 'dependency_scan_failed',
        resource: AuditHelpers.createResource('vulnerability_scan', reportId),
        outcome: AuditHelpers.createFailureOutcome((error as Error).message),
        metadata: {
          scanType: 'dependency',
          duration: report.metadata.duration,
        },
      });

      throw error;
    }
  }

  /**
   * Run code vulnerability scan
   */
  async scanCode(): Promise<VulnerabilityReport> {
    const reportId = `code_scan_${Date.now()}`;
    const startTime = Date.now();

    logger.info('Starting code vulnerability scan', { reportId });

    const report: VulnerabilityReport = {
      id: reportId,
      scanType: 'code',
      timestamp: new Date(),
      status: 'running',
      summary: { total: 0, critical: 0, high: 0, medium: 0, low: 0, info: 0 },
      vulnerabilities: [],
      metadata: {
        scanner: 'eslint-security',
        version: '1.0.0',
        duration: 0,
        target: 'src/',
      },
    };

    this.reports.set(reportId, report);

    try {
      // Run ESLint security rules
      const eslintResults = await this.runESLintSecurity();

      // Run SonarQube scan if configured
      let sonarResults: any[] = [];
      if (this.config.integrations.sonarqube?.url) {
        sonarResults = await this.runSonarQubeScan();
      }

      // Process results
      const vulnerabilities = this.processESLintResults(eslintResults).concat(
        this.processSonarResults(sonarResults)
      );

      // Update report
      report.vulnerabilities = vulnerabilities;
      report.summary = this.calculateSummary(vulnerabilities);
      report.status = 'completed';
      report.metadata.duration = Date.now() - startTime;

      // Store vulnerabilities
      vulnerabilities.forEach((vuln) => {
        this.vulnerabilities.set(vuln.id, vuln);
      });

      logger.info('Code vulnerability scan completed', {
        reportId,
        vulnerabilities: report.summary,
        duration: report.metadata.duration,
      });

      return report;
    } catch (error) {
      report.status = 'failed';
      report.metadata.duration = Date.now() - startTime;

      logger.error('Code vulnerability scan failed', {
        reportId,
        error: (error as Error).message,
      });

      throw error;
    }
  }

  /**
   * Run infrastructure vulnerability scan
   */
  async scanInfrastructure(): Promise<VulnerabilityReport> {
    const reportId = `infra_scan_${Date.now()}`;
    const startTime = Date.now();

    logger.info('Starting infrastructure vulnerability scan', { reportId });

    const report: VulnerabilityReport = {
      id: reportId,
      scanType: 'infrastructure',
      timestamp: new Date(),
      status: 'running',
      summary: { total: 0, critical: 0, high: 0, medium: 0, low: 0, info: 0 },
      vulnerabilities: [],
      metadata: {
        scanner: 'trivy',
        version: '1.0.0',
        duration: 0,
        target: 'docker-image',
      },
    };

    this.reports.set(reportId, report);

    try {
      // Run Trivy scan if configured
      let trivyResults: any[] = [];
      if (this.config.integrations.trivy?.enabled) {
        trivyResults = await this.runTrivyScan();
      }

      // Process results
      const vulnerabilities = this.processTrivyResults(trivyResults);

      // Update report
      report.vulnerabilities = vulnerabilities;
      report.summary = this.calculateSummary(vulnerabilities);
      report.status = 'completed';
      report.metadata.duration = Date.now() - startTime;

      logger.info('Infrastructure vulnerability scan completed', {
        reportId,
        vulnerabilities: report.summary,
        duration: report.metadata.duration,
      });

      return report;
    } catch (error) {
      report.status = 'failed';
      report.metadata.duration = Date.now() - startTime;

      logger.error('Infrastructure vulnerability scan failed', {
        reportId,
        error: (error as Error).message,
      });

      throw error;
    }
  } /**
  
 * Run comprehensive security scan
   */
  async runComprehensiveScan(): Promise<VulnerabilityReport[]> {
    logger.info('Starting comprehensive vulnerability scan');

    const reports: VulnerabilityReport[] = [];

    try {
      // Run all configured scan types
      if (this.config.scanTypes.includes('dependency')) {
        reports.push(await this.scanDependencies());
      }

      if (this.config.scanTypes.includes('code')) {
        reports.push(await this.scanCode());
      }

      if (this.config.scanTypes.includes('infrastructure')) {
        reports.push(await this.scanInfrastructure());
      }

      // Check thresholds
      const overallSummary = this.calculateOverallSummary(reports);
      const thresholdViolations = this.checkThresholds(overallSummary);

      if (thresholdViolations.length > 0) {
        logger.warn('Vulnerability scan threshold violations detected', {
          violations: thresholdViolations,
          summary: overallSummary,
        });

        // Record security event
        metricsManager.recordSecurityEvent(
          'vulnerability_threshold_violation',
          'high',
          'vulnerability-scanner',
          thresholdViolations.length
        );
      }

      logger.info('Comprehensive vulnerability scan completed', {
        reportsGenerated: reports.length,
        overallSummary,
        thresholdViolations,
      });

      return reports;
    } catch (error) {
      logger.error('Comprehensive vulnerability scan failed', {
        error: (error as Error).message,
      });
      throw error;
    }
  }

  /**
   * Get vulnerability report
   */
  getReport(reportId: string): VulnerabilityReport | null {
    return this.reports.get(reportId) || null;
  }

  /**
   * Get all reports
   */
  getAllReports(): VulnerabilityReport[] {
    return Array.from(this.reports.values());
  }

  /**
   * Get vulnerability by ID
   */
  getVulnerability(vulnerabilityId: string): Vulnerability | null {
    return this.vulnerabilities.get(vulnerabilityId) || null;
  }

  /**
   * Update vulnerability status
   */
  async updateVulnerabilityStatus(
    vulnerabilityId: string,
    status: Vulnerability['status'],
    reason?: string
  ): Promise<void> {
    const vulnerability = this.vulnerabilities.get(vulnerabilityId);
    if (!vulnerability) {
      throw new Error('Vulnerability not found');
    }

    const oldStatus = vulnerability.status;
    vulnerability.status = status;

    // Audit trail
    await auditTrailManager.recordEvent({
      actor: AuditHelpers.createSystemActor('vulnerability-manager'),
      action: 'vulnerability_status_updated',
      resource: AuditHelpers.createResource(
        'vulnerability',
        vulnerabilityId,
        vulnerability.title
      ),
      outcome: AuditHelpers.createSuccessOutcome(),
      metadata: {
        oldStatus,
        newStatus: status,
        reason,
        severity: vulnerability.severity,
        component: vulnerability.component,
      },
    });

    logger.info('Vulnerability status updated', {
      vulnerabilityId,
      oldStatus,
      newStatus: status,
      reason,
    });
  }

  /**
   * Get vulnerability statistics
   */
  getVulnerabilityStatistics(): {
    total: number;
    bySeverity: Record<string, number>;
    byStatus: Record<string, number>;
    byCategory: Record<string, number>;
    recentScans: number;
  } {
    const vulnerabilities = Array.from(this.vulnerabilities.values());
    const recentReports = Array.from(this.reports.values()).filter(
      (r) => r.timestamp > new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
    );

    const bySeverity: Record<string, number> = {};
    const byStatus: Record<string, number> = {};
    const byCategory: Record<string, number> = {};

    vulnerabilities.forEach((vuln) => {
      bySeverity[vuln.severity] = (bySeverity[vuln.severity] || 0) + 1;
      byStatus[vuln.status] = (byStatus[vuln.status] || 0) + 1;
      byCategory[vuln.category] = (byCategory[vuln.category] || 0) + 1;
    });

    return {
      total: vulnerabilities.length,
      bySeverity,
      byStatus,
      byCategory,
      recentScans: recentReports.length,
    };
  }

  /**
   * Run npm audit
   */
  private async runNpmAudit(): Promise<any> {
    // Simulate npm audit results
    return {
      advisories: {
        '1': {
          id: 1,
          title: 'Prototype Pollution',
          module_name: 'lodash',
          severity: 'high',
          cves: ['CVE-2019-10744'],
          vulnerable_versions: '<4.17.12',
          patched_versions: '>=4.17.12',
        },
      },
    };
  }

  /**
   * Run Snyk scan
   */
  private async runSnykScan(): Promise<any[]> {
    // Simulate Snyk results
    return [
      {
        id: 'SNYK-JS-LODASH-567746',
        title: 'Prototype Pollution',
        severity: 'high',
        package: 'lodash',
        version: '4.17.11',
        fixedIn: ['4.17.12'],
      },
    ];
  }

  /**
   * Run ESLint security scan
   */
  private async runESLintSecurity(): Promise<any[]> {
    // Simulate ESLint security results
    return [
      {
        ruleId: 'security/detect-object-injection',
        severity: 2,
        message: 'Detected object injection sink',
        line: 42,
        column: 10,
        filePath: 'src/example.ts',
      },
    ];
  }

  /**
   * Run SonarQube scan
   */
  private async runSonarQubeScan(): Promise<any[]> {
    // Simulate SonarQube results
    return [
      {
        key: 'squid:S2068',
        rule: 'squid:S2068',
        severity: 'BLOCKER',
        message: 'Hard-coded credentials are security-sensitive',
        component: 'src/config.ts',
        line: 15,
      },
    ];
  }

  /**
   * Run Trivy scan
   */
  private async runTrivyScan(): Promise<any[]> {
    // Simulate Trivy results
    return [
      {
        VulnerabilityID: 'CVE-2021-44228',
        PkgName: 'log4j-core',
        InstalledVersion: '2.14.1',
        FixedVersion: '2.15.0',
        Severity: 'CRITICAL',
        Title:
          'Apache Log4j2 JNDI features do not protect against attacker controlled LDAP',
      },
    ];
  }

  /**
   * Process npm audit results
   */
  private processNpmAuditResults(results: any): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];

    if (results.advisories) {
      Object.values(results.advisories).forEach((advisory: any) => {
        const vulnerability: Vulnerability = {
          id: `npm_${advisory.id}`,
          cve: advisory.cves?.[0],
          title: advisory.title,
          description: `Vulnerability in ${advisory.module_name}`,
          severity: advisory.severity as Vulnerability['severity'],
          score: this.severityToScore(advisory.severity),
          category: 'dependency',
          component: advisory.module_name,
          version: advisory.vulnerable_versions,
          fixedVersion: advisory.patched_versions,
          references: advisory.references || [],
          exploitable:
            advisory.severity === 'critical' || advisory.severity === 'high',
          patchAvailable: !!advisory.patched_versions,
          firstDetected: new Date(),
          lastSeen: new Date(),
          status: 'open',
        };

        vulnerabilities.push(vulnerability);
      });
    }

    return vulnerabilities;
  }

  /**
   * Process Snyk results
   */
  private processSnykResults(results: any[]): Vulnerability[] {
    return results.map((result) => ({
      id: `snyk_${result.id}`,
      title: result.title,
      description: `Snyk vulnerability in ${result.package}`,
      severity: result.severity as Vulnerability['severity'],
      score: this.severityToScore(result.severity),
      category: 'dependency',
      component: result.package,
      version: result.version,
      fixedVersion: result.fixedIn?.[0],
      references: [],
      exploitable: result.severity === 'critical' || result.severity === 'high',
      patchAvailable: !!result.fixedIn?.length,
      firstDetected: new Date(),
      lastSeen: new Date(),
      status: 'open',
    }));
  }

  /**
   * Process ESLint results
   */
  private processESLintResults(results: any[]): Vulnerability[] {
    return results.map((result, index) => ({
      id: `eslint_${index}_${Date.now()}`,
      title: result.message,
      description: `ESLint security rule violation: ${result.ruleId}`,
      severity:
        result.severity === 2 ? 'medium' : ('low' as Vulnerability['severity']),
      score: result.severity === 2 ? 5.0 : 2.0,
      category: 'code',
      component: result.filePath,
      references: [],
      exploitable: false,
      patchAvailable: true,
      firstDetected: new Date(),
      lastSeen: new Date(),
      status: 'open',
    }));
  }

  /**
   * Process SonarQube results
   */
  private processSonarResults(results: any[]): Vulnerability[] {
    return results.map((result, index) => ({
      id: `sonar_${result.key}_${index}`,
      title: result.message,
      description: `SonarQube security issue: ${result.rule}`,
      severity: this.sonarSeverityToVulnSeverity(result.severity),
      score: this.sonarSeverityToScore(result.severity),
      category: 'code',
      component: result.component,
      references: [],
      exploitable:
        result.severity === 'BLOCKER' || result.severity === 'CRITICAL',
      patchAvailable: true,
      firstDetected: new Date(),
      lastSeen: new Date(),
      status: 'open',
    }));
  }

  /**
   * Process Trivy results
   */
  private processTrivyResults(results: any[]): Vulnerability[] {
    return results.map((result) => ({
      id: `trivy_${result.VulnerabilityID}`,
      cve: result.VulnerabilityID,
      title: result.Title,
      description: `Container vulnerability in ${result.PkgName}`,
      severity: result.Severity.toLowerCase() as Vulnerability['severity'],
      score: this.severityToScore(result.Severity.toLowerCase()),
      category: 'infrastructure',
      component: result.PkgName,
      version: result.InstalledVersion,
      fixedVersion: result.FixedVersion,
      references: [],
      exploitable: result.Severity === 'CRITICAL' || result.Severity === 'HIGH',
      patchAvailable: !!result.FixedVersion,
      firstDetected: new Date(),
      lastSeen: new Date(),
      status: 'open',
    }));
  }

  /**
   * Calculate summary from vulnerabilities
   */
  private calculateSummary(
    vulnerabilities: Vulnerability[]
  ): VulnerabilityReport['summary'] {
    const summary = {
      total: 0,
      critical: 0,
      high: 0,
      medium: 0,
      low: 0,
      info: 0,
    };

    vulnerabilities.forEach((vuln) => {
      summary.total++;
      summary[vuln.severity]++;
    });

    return summary;
  }

  /**
   * Calculate overall summary from multiple reports
   */
  private calculateOverallSummary(
    reports: VulnerabilityReport[]
  ): VulnerabilityReport['summary'] {
    const summary = {
      total: 0,
      critical: 0,
      high: 0,
      medium: 0,
      low: 0,
      info: 0,
    };

    reports.forEach((report) => {
      summary.total += report.summary.total;
      summary.critical += report.summary.critical;
      summary.high += report.summary.high;
      summary.medium += report.summary.medium;
      summary.low += report.summary.low;
      summary.info += report.summary.info;
    });

    return summary;
  }

  /**
   * Check vulnerability thresholds
   */
  private checkThresholds(summary: VulnerabilityReport['summary']): string[] {
    const violations: string[] = [];

    if (summary.critical > this.config.thresholds.critical) {
      violations.push(
        `Critical vulnerabilities: ${summary.critical} > ${this.config.thresholds.critical}`
      );
    }

    if (summary.high > this.config.thresholds.high) {
      violations.push(
        `High vulnerabilities: ${summary.high} > ${this.config.thresholds.high}`
      );
    }

    if (summary.medium > this.config.thresholds.medium) {
      violations.push(
        `Medium vulnerabilities: ${summary.medium} > ${this.config.thresholds.medium}`
      );
    }

    return violations;
  }

  /**
   * Convert severity to CVSS score
   */
  private severityToScore(severity: string): number {
    switch (severity.toLowerCase()) {
      case 'critical':
        return 9.0;
      case 'high':
        return 7.0;
      case 'medium':
        return 5.0;
      case 'low':
        return 3.0;
      case 'info':
        return 1.0;
      default:
        return 0.0;
    }
  }

  /**
   * Convert SonarQube severity to vulnerability severity
   */
  private sonarSeverityToVulnSeverity(
    severity: string
  ): Vulnerability['severity'] {
    switch (severity) {
      case 'BLOCKER':
        return 'critical';
      case 'CRITICAL':
        return 'high';
      case 'MAJOR':
        return 'medium';
      case 'MINOR':
        return 'low';
      case 'INFO':
        return 'info';
      default:
        return 'low';
    }
  }

  /**
   * Convert SonarQube severity to score
   */
  private sonarSeverityToScore(severity: string): number {
    switch (severity) {
      case 'BLOCKER':
        return 9.0;
      case 'CRITICAL':
        return 7.0;
      case 'MAJOR':
        return 5.0;
      case 'MINOR':
        return 3.0;
      case 'INFO':
        return 1.0;
      default:
        return 0.0;
    }
  }

  /**
   * Start scheduled scans
   */
  private startScheduledScans(): void {
    // Parse cron schedule (simplified - in production use a proper cron library)
    const scheduleMs = 24 * 60 * 60 * 1000; // Daily for now

    this.scanInterval = setInterval(async () => {
      try {
        logger.info('Starting scheduled vulnerability scan');
        await this.runComprehensiveScan();
      } catch (error) {
        logger.error('Scheduled vulnerability scan failed', {
          error: (error as Error).message,
        });
      }
    }, scheduleMs);

    logger.info('Vulnerability scanner scheduled', {
      schedule: this.config.schedule,
      scanTypes: this.config.scanTypes,
    });
  }

  /**
   * Stop scheduled scans
   */
  stopScheduledScans(): void {
    if (this.scanInterval) {
      clearInterval(this.scanInterval);
      this.scanInterval = undefined;
      logger.info('Vulnerability scanner scheduling stopped');
    }
  }

  /**
   * Health check
   */
  healthCheck(): {
    status: 'healthy' | 'degraded' | 'unhealthy';
    details: Record<string, any>;
  } {
    const stats = this.getVulnerabilityStatistics();
    const recentReports = Array.from(this.reports.values()).filter(
      (r) => r.timestamp > new Date(Date.now() - 24 * 60 * 60 * 1000)
    );

    const criticalVulns = stats.bySeverity.critical || 0;
    const highVulns = stats.bySeverity.high || 0;

    let status: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';
    if (criticalVulns > 0) {
      status = 'unhealthy';
    } else if (highVulns > 10) {
      status = 'degraded';
    }

    return {
      status,
      details: {
        enabled: this.config.enabled,
        totalVulnerabilities: stats.total,
        criticalVulnerabilities: criticalVulns,
        highVulnerabilities: highVulns,
        recentScans: recentReports.length,
        scheduledScanning: !!this.scanInterval,
        configuredScanTypes: this.config.scanTypes,
      },
    };
  }
}

// Export singleton instance
export const vulnerabilityScannerService = new VulnerabilityScannerService();
